package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"go-Attack/CVEs"
	"io/ioutil"
	"log"
	"net/http"
	"reflect"
	"strings"
	"sync"
)

var functionNames = []string{
	"CVE_2024_1021",
	"CVE_2024_28895",
	"CVE_2024_3400",
	"CVE_2024_32709",
	"CVE_2024_36991",
	"CVE_2024_5084",
	"CVE_2024_36401",
	"CVE_2024_23692",
	"CVE_2024_0195",
	"CVE_2024_31982",
	"CVE_2024_39943",
	"CVE_2024_4879",
	"CVE_2024_5217",
	"CVE_2024_5178",
	"CVE_2024_40050",
	"QVD_2024_26136",
	"CNVD_2024_15077",
	"CVE_2024_39914",
	"CVE_2024_32238",
	"KTO_SQLInjection",
	"KoronAIO_SQLInjection",
	"FanRuan_RCE",
	"JinHeOA_ArbitraryFileReading",
	"GuangLianDaOA_XXE",
	"RuiMingCrocus_ArbitraryFileReading",
	"SaiLan_ArbitraryFileReading",
	"XunRaoKeJiX2_AddUser",
}
var Attack bool
var FileData string
var Show bool
var Banner string = `
 ____  _     _____ ____        ____  _____  _____  ____  _  __
/   _\/ \ |\/  __// ___\      /  _ \/__ __\/__ __\/   _\/ |/ /
|  /  | | //|  \  ||___ _____ | / \|  / \    / \  |  /  |   /
|  \__| \// |  /_ \___ |\____\| |-||  | |    | |  |  \_ |   \
\____/\__/  \____\\____/      \_/ \|  \_/    \_/  \____/\_|\_\

               ____ ___  _  ___  _ ____ ___  _ _     ____
              /  _ \\  \//  \  \///   _\\  \/// \   /  _ \
        _____ | | // \  /    \  / |  /   \  / | |   | / \|
        \____\| |_\\ / /     / /  |  \_  /  \ | |_/\| \_/|
              \____//_/     /_/   \____//__/\\\____/\____/`

func main() {
	urlFlag := flag.String("u", "", "目标url") //默认为空
	ListFlag := flag.String("list", "", "目标urls文件")
	ShowFlag := flag.Bool("show", false, "展示所有支持漏洞")
	AttckFlag := flag.Bool("attack", false, "是否加入攻击参数")
	CookieFlag := flag.String("cookie", "", "设置cookie")
	flag.Parse() //解析命令行参数

	Attack = *AttckFlag
	CVEs.Cookie = *CookieFlag
	Show = *ShowFlag
	//函数切片
	cvesFunctions := []func(string, bool) error{
		CVEs.CVE_2024_1021,
		CVEs.CVE_2024_28895,
		CVEs.CVE_2024_3400,
		CVEs.CVE_2024_32709,
		CVEs.CVE_2024_36991,
		CVEs.CVE_2024_5084,
		CVEs.CVE_2024_36401,
		CVEs.CVE_2024_23692,
		CVEs.CVE_2024_0195,
		CVEs.CVE_2024_31982,
		CVEs.CVE_2024_39943,
		CVEs.CVE_2024_4879,
		CVEs.CVE_2024_5217,
		CVEs.CVE_2024_5178,
		CVEs.CVE_2024_40050,
		CVEs.QVD_2024_26136,
		CVEs.CNVD_2024_15077,
		CVEs.CVE_2024_39914,
		CVEs.CVE_2024_32238,
		CVEs.KTO_SQLInjection,
		CVEs.KoronAIO_SQLInjection,
		CVEs.FanRuan_RCE,
		CVEs.JinHeOA_ArbitraryFileReading,
		CVEs.GuangLianDaOA_XXE,
		CVEs.RuiMingCrocus_ArbitraryFileReading,
		CVEs.SaiLan_ArbitraryFileReading,
		CVEs.XunRaoKeJiX2_AddUser,
	}

	if Show == true {
		for _, name := range functionNames {
			fmt.Println(name)
		}
		return
	}

	if *urlFlag == "" && *ListFlag == "" {
		fmt.Println("请输入目标url或url列表,参数-u或-l")
		return
	}

	if *urlFlag != "" && *ListFlag == "" {
		// 去除URL末尾的斜杠
		url := strings.TrimSuffix(*urlFlag, "/")
		if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
			url = "http://" + url
		}

		fmt.Println(Banner)

		// 使用 WaitGroup 来等待所有 Goroutine 的完成
		var wg sync.WaitGroup

		// 创建结果通道，用于从 Goroutine 中收集任务的结果
		results := make(chan error)

		// 启动 Goroutine 执行任务
		for _, cvefunc := range cvesFunctions {
			wg.Add(1)
			go func(cvefunc func(string, bool) error) {
				defer wg.Done()
				err := cvefunc(url, Attack)
				results <- err
			}(cvefunc)
		}

		// 在另一个 Goroutine 中等待所有任务完成并关闭结果通道
		go func() {
			wg.Wait()
			close(results)
		}()

		// 从结果通道中读取任务结果
		for err := range results {
			if err != nil {

			}
		}

		return
	} else {
		fileData, err := ioutil.ReadFile(*ListFlag)
		if err != nil {
			fmt.Println("url文件错误")
			return
		}
		FileData := string(fileData)
		urls := strings.Split(FileData, "\n")
		fmt.Println(Banner)

		// 使用 WaitGroup 来等待所有 Goroutine 的完成
		var wg sync.WaitGroup

		// 创建结果通道，用于从 Goroutine 中收集任务的结果
		results := make(chan error)

		// 启动 Goroutine 执行任务
		for _, Targeturl := range urls {
			wg.Add(1)
			go func(Targeturl string) {
				defer wg.Done()
				Targeturl = strings.TrimSpace(Targeturl)
				Targeturl = strings.TrimSuffix(Targeturl, "/")
				if Targeturl != "" {
					if !strings.HasPrefix(Targeturl, "http://") && !strings.HasPrefix(Targeturl, "https://") {
						Targeturl = "http://" + Targeturl
					}
					if !isValidURL(Targeturl) {
						return // 跳过无效的 URL
					}
					// 遍历每个函数
					for _, cvefunc := range cvesFunctions {
						defer func() {
							if r := recover(); r != nil {
								fmt.Println("")
							}
						}()
						err := cvefunc(Targeturl, Attack)
						results <- err
					}
				}
			}(Targeturl)
		}

		// 在另一个 Goroutine 中等待所有任务完成并关闭结果通道
		go func() {
			wg.Wait()
			close(results)
		}()

		// 从结果通道中读取任务结果
		for err := range results {
			if err != nil {
				log.Println("")
			}
		}

		return
	}
}

func isValidURL(url string) bool {
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true}, // 跳过证书验证，用于测试环境
	}

	client := &http.Client{Transport: tr}
	resp, err := client.Get(url)

	if err != nil {
		return false // 发生错误，URL 无效
	}
	defer resp.Body.Close()

	return true // URL 有效
}